LUD-18: Payer identity in `payRequest` protocol.
================================================

`author: akumaigorodski` `author: hampus_s` `discussion: https://t.me/lnurl/14436` `author: fiatjaf` `author: dpad85` `discussion: https://t.me/lnurl/24003` `discussion: https://github.com/fiatjaf/lnurl-rfc/pull/101`

---

The idea here is that the payer can identify itself when paying. The scope varies from free-form names (or [LUD-16](16.md) internet identifiers) useful for loose identification in comments or similar things, to cryptographic keys for proof of payment, to authentication keys for future login into a `SERVICE`'s website after a payment and other use cases.

Aside from that, the payer ids are also committed to the invoice by means of the `descriptionHash` property, which ensures strong cryptographic guarantees for proof of payment.

## 1. `payerData` record

If `SERVICE` wants to get one or more types of payer identities from `WALLET` then it MUST alter its JSON response to the first callback to include a `payerData` field, as follows (notice that the `payerData` record below has a bunch of fields only for completion, an actual response will likely contain just a subset of these):

```diff
 {
   "callback": String,
   "maxSendable": number,
   "minSendable": number,
   "metadata": string,
   "payerData": {
     "name": { "mandatory": boolean },
     "pubkey": { "mandatory": boolean },
     "identifier": { "mandatory": boolean },
     "email": { "mandatory": boolean },
     "auth": {
        "mandatory": boolean,
        "k1": string // hex encoded 32 bytes of challenge
     },
+    "lud16": { "mandatory": boolean },
+    "revauth": { "mandatory": boolean },
     ...other fields may be negotiated
   },
   "tag": "payRequest",
 }
```

Notice that just including the payer id kind ("name", "pubkey" etc.) in the `payerData` record is enough to signal acceptance of that kind.

## 2. Specifying payer identity before sending a payment

In response to seeing a `payerData` record in the initial response from `SERVICE`, `WALLET` attaches a `payerdata` query parameter to LNURL-PAY callback with value set to a JSON object:

```
  <callback><?|&>amount=<milliSatoshi>&payerdata=<urlencode({json object})>
```

The JSON object MUST be of the following format (notice that these fields are shown only for completion, in practice it will likely contain just a subset of these):

```diff
{
  "name": string, // free form string
  "pubkey": string, // hex(<randomly generated secp256k1 pubkey>),
  "auth": {
    "key": string, // hex(<linkingKey>)
    "k1": string, // same as received from service on section 1
    "sig": string, // following LUD-04: hex(sign(hexToBytes(<k1>), <linkingPrivKey>))
  },
  "email": string,
  "identifier": string,
+ "lud16": string,
+ "revauth": {
+      "mandatory": boolean,
+      "k1": string // hex encoded 32 bytes of challenge
+   },
  ...other fields may be included if supported by wallet and requested by service
}
```

Each key in this JSON object should correspond to a requested payerdata from the `payerData` record received from `SERVICE`.

`WALLET` CAN send any of the payer id kinds if they are listed in the `payerData` record. But if any is marked as `"mandatory": true` then `WALLET` MUST send or otherwise do not proceed with the payment flow.

`WALLET` SHOULD NOT send payer identity types omitted in `payerData` record, none at all if record is not present.

`LN Service` takes the GET request and returns JSON response of form:

```diff
{
-   pr: string, // bech32-serialized lightning invoice
+   pr: string, // bech32-serialized lightning invoice if amount > 0
    routes: [], // an empty array
+   "revauth": {
+        "key": string, // hex(<linkingKey>)
+        "k1": string, // same as received from wallet
+        "sig": string, // following LUD-04: hex(sign(hexToBytes(<k1>), <linkingPrivKey>))
+    }
}
```

or

```JSON
{"status":"ERROR", "reason":"error details..."}
```

***If `WALLET` marked `revauth` as `"mandatory": true` then `SERVICE` MUST provide `revauth`.***

## 3. Usage Notes

The `revauth` dialog provides a mechanism for reverse authentication which can prevent spoofing by confirming that the `SERVICE` associated with a `LUD-16` identifier has the same linkingkey as a `WALLET`.  Associating multiple linking keys with a `LUD-16` identifer causes some loss of privacy.  This can be mitigated by using multiple `LUD-16` identifers for different contexts.  It is entirely at the discretion of the user, `WALLET` provider, and `SERVICE` which activities they would like to associate with `LUD-16` identifers.  

Preventing sppofing means that the owner of physical or virtual items or privileges can be identified by a `LUD-16` identifer such that the owner can prove their identity and claim their items or privileges using their `WALLET`.

Preventing spoofing also means that useful payments with low, zero, or negative amounts can be separated from spam based on the `LUD-16` identifer of origin.  A service can signal their acceptance of payments with zero or negative amounts by setting `minsendable` to zero or a negative value.  The use case for a payment with amount=0 would be to perform a `revauth` without the `SERVICE` having to generate an invoice.  A negative payment (amount<0) represents a `WALLET` requesting funds from a `SERVICE`.  The negative payment should include `identifier` and `lud16`.  The `SERVICE` can verify the origin of the negative payment and ask the user to authorize the payment at a later time when the user logs on.  Negative payments give the `Lud-16` identifer functionality similar to the pull payments implemented in btcpay, but with a more streamlined user experience.  Merchants simply need to know the `LUD-16` identifer of their customers to pull payments from them them and the customer can authorize each payout with a single click or apply an automatic criteria based on the `LUD-16` identifer of origin.
